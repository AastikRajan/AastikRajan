{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to ocm2","text":"<p>This python package extracts subdatasets from OCM-2 HDF file, georeference them and exports them to GeoTIFF. The package also creates a cloud mask layer.</p> <ul> <li>Free software: MIT license</li> <li>Documentation: https://akhi9661.github.io/ocm2</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Extract sub-datasets from OCM-2 HDF file</li> <li>Geo-reference the extracted GeoTIFF files or extract and geo-reference them if not extracted.</li> </ul>"},{"location":"#to-do","title":"TO-DO","text":"<ul> <li>Add documentation and examples</li> </ul>"},{"location":"#credits","title":"Credits","text":"<p>This package was created with Cookiecutter and the giswqs/pypackage project template.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#v020-28-04-2023","title":"v0.2.0 - 28-04-2023","text":"<ul> <li>Added all functions. Ready to use.</li> </ul>"},{"location":"changelog/#v010-06-04-2023","title":"v0.1.0 - 06-04-2023","text":"<ul> <li>Added major functions for exporting sub-datasets and geo-referencing</li> </ul>"},{"location":"changelog/#v002-25-03-2023","title":"v0.0.2 - 25-03-2023","text":"<ul> <li>Added minor fixes to documentation.</li> </ul>"},{"location":"changelog/#v001-23-03-2023","title":"v0.0.1 - 23-03-2023","text":"<ul> <li>Initial release.</li> </ul> <p>Improvement:</p> <ul> <li>TBD</li> </ul> <p>New Features:</p> <ul> <li>TBD</li> </ul>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p> <p>You can contribute in many ways:</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/akhi9661/ocm2/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with <code>bug</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with <code>enhancement</code> and <code>help wanted</code> is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>ocm2 could always use more documentation, whether as part of the official ocm2 docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/akhi9661/ocm2/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome :)</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up ocm2 for local development.</p> <ol> <li> <p>Fork the ocm2 repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>$ git clone git@github.com:your_name_here/ocm2.git\n</code></pre> </li> <li> <p>Install your local copy into a virtualenv. Assuming you have     virtualenvwrapper installed, this is how you set up your fork for     local development:</p> <pre><code>$ mkvirtualenv ocm2\n$ cd ocm2/\n$ python setup.py develop\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>$ git checkout -b name-of-your-bugfix-or-feature\n</code></pre> <p>Now you can make your changes locally.</p> </li> <li> <p>When you're done making changes, check that your changes pass flake8     and the tests, including testing other Python versions with tox:</p> <pre><code>$ flake8 ocm2 tests\n$ python setup.py test or pytest\n$ tox\n</code></pre> <p>To get flake8 and tox, just pip install them into your virtualenv.</p> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>$ git add .\n$ git commit -m \"Your detailed description of your changes.\"\n$ git push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests.</li> <li>If the pull request adds functionality, the docs should be updated.     Put your new functionality into a function with a docstring, and add     the feature to the list in README.rst.</li> <li>The pull request should work for Python 3.5, 3.6, 3.7 and 3.8, and     for PyPy. Check https://github.com/akhi9661/ocm2/pull_requests and make sure that the tests pass for all     supported Python versions.</li> </ol>"},{"location":"faq/","title":"FAQ","text":""},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install ocm2, run this command in your terminal:</p> <pre><code>pip install ocm2\n</code></pre> <p>This is the preferred method to install ocm2, as it will always install the most recent stable release.</p> <p>If you don't have pip installed, this Python installation guide can guide you through the process.</p>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>The sources for ocm2 can be downloaded from the Github repo.</p> <p>You can clone the public repository:</p> <pre><code>git clone git://github.com/akhi9661/ocm2\n</code></pre>"},{"location":"ocm2/","title":"ocm2 modules","text":""},{"location":"ocm2/#ocm2.ocm2.ExportSubdatasets","title":"<code>ExportSubdatasets(path, hdf_file)</code>","text":"<p>This function takes the folder path and the HDF file as input and exports individual layers to TIFF (named GeoTIFF)</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the folder containing the HDF file.</p> required <code>hdf_file</code> <code>str</code> <p>Name of the HDF file.</p> required <p>Returns:</p> Type Description <code>opf_tif (str)</code> <p>Path to the folder containing the GeoTiff files.</p> Source code in <code>ocm2/ocm2.py</code> <pre><code>def ExportSubdatasets(path, hdf_file):\n\n\"\"\"   \n    This function takes the folder path and the HDF file as input and exports individual layers to TIFF (named GeoTIFF)\n\n    Parameters:\n        path (str): Path to the folder containing the HDF file.\n        hdf_file (str): Name of the HDF file.\n\n    Returns:\n        opf_tif (str): Path to the folder containing the GeoTiff files.\n\n    \"\"\"\n    opf_tif = os.path.join(path, 'GeoTiff')\n    if os.path.exists(opf_tif):\n        shutil.rmtree(opf_tif)\n    os.makedirs(opf_tif)\n\n    inp_hdf = os.path.join(path, hdf_file)\n    hdf_ds = gdal.Open(inp_hdf, gdal.GA_ReadOnly)\n    subdatasets = hdf_ds.GetSubDatasets()\n\n    for i in range(0, len(subdatasets)):\n        subdataset_name = subdatasets[i][0]\n        band_ds = gdal.Open(subdataset_name, gdal.GA_ReadOnly)\n        band_path = os.path.join(opf_tif, 'band{0}.TIF'.format(i))\n        if band_ds.RasterCount &gt; 1:\n            for j in range(1,band_ds.RasterCount + 1):\n                band = band_ds.GetRasterBand(j)\n                band_array = band.ReadAsArray()\n        else:\n            band_array = band_ds.ReadAsArray()\n\n        out_ds = gdal.GetDriverByName('GTiff').Create(band_path,\n                                                      band_ds.RasterXSize,\n                                                      band_ds.RasterYSize,\n                                                      1,\n                                                      gdal.GDT_Float64,\n                                                      ['COMPRESS=LZW', 'TILED=YES'])\n\n\n        out_ds.SetGeoTransform(band_ds.GetGeoTransform())\n        out_ds.SetProjection(band_ds.GetProjection())\n        out_ds.GetRasterBand(1).WriteArray(band_array)\n        out_ds.GetRasterBand(1).SetNoDataValue(-32768)\n\n    out_ds = None\n\n    return opf_tif\n</code></pre>"},{"location":"ocm2/#ocm2.ocm2.Georeference","title":"<code>Georeference(inpf, gtif, meta, opf_ref)</code>","text":"<p>This function georeferences the GeoTiff files using the metadata of the HDF file.</p> <p>Parameters:</p> Name Type Description Default <code>inpf</code> <code>str</code> <p>Path to the folder containing the GeoTiff files.</p> required <code>gtif</code> <code>str</code> <p>Name of the GeoTiff file.</p> required <code>meta</code> <code>dict</code> <p>Dictionary containing the metadata of the HDF file.</p> required <p>Returns:</p> Type Description <code>opf_ref (str)</code> <p>Path to the folder containing the georeferenced GeoTiff files.</p> Source code in <code>ocm2/ocm2.py</code> <pre><code>def Georeference(inpf, gtif, meta, opf_ref):\n\n\"\"\"\n    This function georeferences the GeoTiff files using the metadata of the HDF file.\n\n    Parameters:\n        inpf (str): Path to the folder containing the GeoTiff files.\n        gtif (str): Name of the GeoTiff file.\n        meta (dict): Dictionary containing the metadata of the HDF file.\n\n    Returns:\n        opf_ref (str): Path to the folder containing the georeferenced GeoTiff files.\n\n    \"\"\"\n\n    inp_file = os.path.join(inpf, gtif)\n    band_tif = gdal.Open(inp_file)\n    ext = GetExtent(band_tif)\n\n    ext_pos = [(abs(val[0]), abs(val[1])) for val in ext]\n\n    out_file = os.path.join(opf_ref, os.path.basename(gtif).split('.')[0] + '_georef.TIF')\n    shutil.copy(inp_file, out_file)\n    ds = gdal.Open(out_file, gdal.GA_Update)\n    sr = osr.SpatialReference()\n    sr.ImportFromEPSG(4326) \n\n\n'''\n    Enter the GCPs\n    Format: [map x-coordinate(longitude)], [map y-coordinate (latitude)], [elevation],\n    [image column index(x)], [image row index (y)]\n    If map pixel is negative, multiply it with -1 to make positive since GDAL can't handle negative pixel position that well.\n\n    '''\n\n    gcps = [gdal.GCP(meta[0][0], meta[0][1], 0, ext_pos[0][0], ext_pos[0][1]), \n            gdal.GCP(meta[1][0], meta[1][1], 0, ext_pos[1][0], ext_pos[1][1]),\n            gdal.GCP(meta[2][0], meta[2][1], 0, ext_pos[2][0], ext_pos[2][1]), \n            gdal.GCP(meta[3][0], meta[3][1], 0, ext_pos[3][0], ext_pos[3][1])]\n\n    ds.SetGCPs(gcps, sr.ExportToWkt())\n    ds = None\n\n    return opf_ref\n</code></pre>"},{"location":"ocm2/#ocm2.ocm2.GetExtent","title":"<code>GetExtent(ds)</code>","text":"<p>This function returns the extent of the raster. </p> <p>Parameters:</p> Name Type Description Default <code>ds</code> <code>object</code> <p>GDAL dataset object.</p> required <p>Returns:</p> Type Description <code>(xmin, ymax), (xmax, ymax), (xmax, ymin), (xmin, ymin) (tuple)</code> <p>Extent of the raster.</p> Source code in <code>ocm2/ocm2.py</code> <pre><code>def GetExtent(ds):\n\n\"\"\"\n    This function returns the extent of the raster. \n\n    Parameters:\n        ds (object): GDAL dataset object.\n\n    Returns:\n        (xmin, ymax), (xmax, ymax), (xmax, ymin), (xmin, ymin) (tuple): Extent of the raster.\n\n    \"\"\"\n\n    xmin, xpixel, _, ymax, _, ypixel = ds.GetGeoTransform()\n    width, height = ds.RasterXSize, ds.RasterYSize\n    xmax = xmin + width * xpixel\n    ymin = ymax + height * ypixel\n\n    return (xmin, ymax), (xmax, ymax), (xmax, ymin), (xmin, ymin)\n</code></pre>"},{"location":"ocm2/#ocm2.ocm2.calc_toa","title":"<code>calc_toa(rad, sun_elev, band_no)</code>","text":"<p>This function calculates the top of atmosphere reflectance.</p> <p>Parameters:</p> Name Type Description Default <code>rad</code> <code>numpy array</code> <p>Array containing the radiance values.</p> required <code>sun_elev</code> <code>float</code> <p>Sun elevation angle.</p> required <code>band_no</code> <code>int</code> <p>Band number.</p> required <p>Returns:</p> Type Description <code>toa_reflectance (numpy array)</code> <p>Array containing the top of atmosphere reflectance values.</p> Source code in <code>ocm2/ocm2.py</code> <pre><code>def calc_toa(rad, sun_elev, band_no):\n\n\"\"\"\n    This function calculates the top of atmosphere reflectance.\n\n    Parameters:\n        rad (numpy array): Array containing the radiance values.\n        sun_elev (float): Sun elevation angle.\n        band_no (int): Band number.\n\n    Returns:\n        toa_reflectance (numpy array): Array containing the top of atmosphere reflectance values.\n\n    \"\"\"\n\n    esol = [1.72815, 1.85211, 1.9721, 1.86697, 1.82781, 1.65765, 1.2897, 0.952073]\n    toa_reflectance = (np.pi * 1 * rad * 10) / (esol[band_no] * 1000 * math.sin(math.radians(sun_elev)))\n    return toa_reflectance\n</code></pre>"},{"location":"ocm2/#ocm2.ocm2.cloudmask_ocm","title":"<code>cloudmask_ocm(inpf, filelist)</code>","text":"<p>This function creates the cloud mask based on Mishra et al. (2018).</p> <p>Parameters:</p> Name Type Description Default <code>inpf</code> <code>str</code> <p>Path to the folder containing the GeoTiff files.</p> required <code>filelist</code> <code>list</code> <p>List containing the GeoTiff files.</p> required <p>Returns:</p> Type Description <code>cldmsk (numpy array)</code> <p>Array containing the cloud mask.</p> Source code in <code>ocm2/ocm2.py</code> <pre><code>def cloudmask_ocm(inpf, filelist):\n\n\"\"\"\n    This function creates the cloud mask based on Mishra et al. (2018).\n\n    Parameters:\n        inpf (str): Path to the folder containing the GeoTiff files.\n        filelist (list): List containing the GeoTiff files.\n\n    Returns:\n        cldmsk (numpy array): Array containing the cloud mask.\n\n    \"\"\"\n\n    toa_sum = sum_toa(filelist)\n    toa_diff, toa_ratio, shape, profile = toa_other(filelist) \n\n    cldmsk = np.zeros(shape, dtype = 'float32')\n    cldmsk = np.where(((toa_sum &gt; 2.7) &amp; (toa_ratio &gt; 1.5) &amp; (toa_diff &lt; 0)), 1, 0)\n\n    with (rasterio.open)((os.path.join(inpf, 'cloud_mask.TIF')), 'w', **profile) as (dst):\n        dst.write(cldmsk)\n    dst.close()\n\n    return cldmsk\n</code></pre>"},{"location":"ocm2/#ocm2.ocm2.do_cldmsk","title":"<code>do_cldmsk(opf_ref)</code>","text":"<p>This function calls the function that creates the cloud mask.</p> <p>Parameters:</p> Name Type Description Default <code>opf_ref</code> <code>str</code> <p>Path to the folder containing the output georeferenced GeoTiff files.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>ocm2/ocm2.py</code> <pre><code>def do_cldmsk(opf_ref):\n\n\"\"\"\n    This function calls the function that creates the cloud mask.\n\n    Parameters:\n        opf_ref (str): Path to the folder containing the output georeferenced GeoTiff files.\n\n    Returns:\n        None\n\n    \"\"\"\n\n    files = []\n\n    original = os.listdir(opf_ref)\n    gtif = list(filter(lambda x: x.endswith((\"TIF\", \"tif\", \"img\")), original))\n    for band_name in gtif:\n        if (int(''.join(list(filter(str.isdigit, band_name.split('.')[0].split('_')[0]))))) &lt;= 7:\n            filelist = list_files(opf_ref, band_name, files)\n\n    cldmsk = cloudmask_ocm(opf_ref, filelist)\n\n    return None\n</code></pre>"},{"location":"ocm2/#ocm2.ocm2.do_georef","title":"<code>do_georef(opf_ref, meta, opf_georef)</code>","text":"<p>This function calls the function that georeferences the top of atmosphere reflectance GeoTiff files.</p> <p>Parameters:</p> Name Type Description Default <code>geo_ref</code> <code>str</code> <p>Path to the folder containing the georeferenced GeoTiff files.</p> required <code>meta</code> <code>list</code> <p>List containing the metadata of the HDF files.</p> required <code>opf_georef</code> <code>str</code> <p>Path to the folder containing the output georeferenced GeoTiff files. </p> required <p>Returns:</p> Type Description <code>opf_georef (str)</code> <p>Path to the folder containing the output georeferenced GeoTiff files.</p> Source code in <code>ocm2/ocm2.py</code> <pre><code>def do_georef(opf_ref, meta, opf_georef):\n\n\"\"\"\n    This function calls the function that georeferences the top of atmosphere reflectance GeoTiff files.\n\n    Parameters:\n        geo_ref (str): Path to the folder containing the georeferenced GeoTiff files.\n        meta (list): List containing the metadata of the HDF files.\n        opf_georef (str): Path to the folder containing the output georeferenced GeoTiff files. \n\n    Returns:\n        opf_georef (str): Path to the folder containing the output georeferenced GeoTiff files.\n\n    \"\"\"\n\n    original = os.listdir(opf_ref)\n    gtif = list(filter(lambda x: x.endswith((\"TIF\", \"tif\", \"img\")), original))\n    for band_name in gtif:\n        Georeference(opf_ref, band_name, meta, opf_georef)\n\n    return opf_georef\n</code></pre>"},{"location":"ocm2/#ocm2.ocm2.do_ref","title":"<code>do_ref(opf_tif, meta, opf_ref)</code>","text":"<p>This function calls the function that creates the top of atmosphere reflectance GeoTiff files.</p> <p>Parameters:</p> Name Type Description Default <code>opf_tif</code> <code>str</code> <p>Path to the folder containing the GeoTiff files.</p> required <code>meta</code> <code>list</code> <p>List containing the metadata of the GeoTiff files.</p> required <code>opf_ref</code> <code>str</code> <p>Path to the folder containing the output reflectance GeoTiff files. Temporary folder.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>ocm2/ocm2.py</code> <pre><code>def do_ref(opf_tif, meta, opf_ref):\n\n\"\"\"\n    This function calls the function that creates the top of atmosphere reflectance GeoTiff files.\n\n    Parameters:\n        opf_tif (str): Path to the folder containing the GeoTiff files.\n        meta (list): List containing the metadata of the GeoTiff files.\n        opf_ref (str): Path to the folder containing the output reflectance GeoTiff files. Temporary folder.\n\n    Returns:\n        None\n\n    \"\"\"\n\n    original = os.listdir(opf_tif)\n    gtif = list(filter(lambda x: x.endswith((\"TIF\", \"tif\", \"img\")), original))\n    for band_name in gtif:\n        if (int(''.join(list(filter(str.isdigit, band_name.split('.')[0].split('_')[0]))))) &lt;= 7:\n            toa_convert(opf_tif, band_name, opf_ref, meta[4])\n        else:\n            shutil.copy(os.path.join(opf_tif, band_name), os.path.join(opf_ref, band_name))\n\n    return None\n</code></pre>"},{"location":"ocm2/#ocm2.ocm2.list_files","title":"<code>list_files(inpf, inp_name, files)</code>","text":"<p>This function lists the GeoTiff files.</p> <p>Parameters:</p> Name Type Description Default <code>inpf</code> <code>str</code> <p>Path to the folder containing the GeoTiff files.</p> required <code>inp_name</code> <code>str</code> <p>Name of the GeoTiff file.</p> required <code>files</code> <code>list</code> <p>List containing the GeoTiff files. Empty list at the beginning.</p> required <p>Returns:</p> Type Description <code>files (list)</code> <p>List containing the GeoTiff files.</p> Source code in <code>ocm2/ocm2.py</code> <pre><code>def list_files(inpf, inp_name, files):\n\n\"\"\"\n    This function lists the GeoTiff files.\n\n    Parameters:\n        inpf (str): Path to the folder containing the GeoTiff files.\n        inp_name (str): Name of the GeoTiff file.\n        files (list): List containing the GeoTiff files. Empty list at the beginning.\n\n    Returns:\n        files (list): List containing the GeoTiff files.\n\n    \"\"\"\n\n    files.append(os.path.join(inpf, inp_name))\n    return files\n</code></pre>"},{"location":"ocm2/#ocm2.ocm2.metaInfo","title":"<code>metaInfo(path, hdf_file, input=None)</code>","text":"<p>This function returns the metadata of the HDF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the folder containing the HDF file.</p> required <code>hdf_file</code> <code>str</code> <p>Name of the HDF file.</p> required <p>Returns:      (ulx,  uly), (urx, ury), (brx, bry), (blx, bly), (sun_elev) (tuple): Metadata of the HDF file.</p> Source code in <code>ocm2/ocm2.py</code> <pre><code>def metaInfo(path, hdf_file, input = None):\n\n\n\"\"\"\n    This function returns the metadata of the HDF file.\n\n    Parameters:\n        path (str): Path to the folder containing the HDF file.\n        hdf_file (str): Name of the HDF file.\n\n    Returns: \n        (ulx,  uly), (urx, ury), (brx, bry), (blx, bly), (sun_elev) (tuple): Metadata of the HDF file.\n\n    \"\"\"\n\n    inp = gdal.Open(os.path.join(path, hdf_file))\n    meta = inp.GetMetadata()\n\n    ulx, uly = float(meta['Upper Left Longitude']), float(meta['Upper Left Latitude'])\n    urx, ury = float(meta['Upper Right Longitude']), float(meta['Upper Right Latitude'])\n    blx, bly = float(meta['Lower Left Longitude']), float(meta['Lower Left Latitude'])\n    brx, bry = float(meta['Lower Right Longitude']), float(meta['Lower Right Latitude'])\n\n    sun_elev = float(meta['Sun Elevation Angle'])\n\n    return (ulx,  uly), (urx, ury), (brx, bry), (blx, bly), (sun_elev)\n</code></pre>"},{"location":"ocm2/#ocm2.ocm2.run_ocm2","title":"<code>run_ocm2(path, hdf_file)</code>","text":"<p>This is the main function of the script. It calls all the other functions. </p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the folder containing the HDF files.</p> required <code>hdf_file</code> <code>str</code> <p>Name of the HDF file.</p> required <p>Returns:</p> Type Description <code>opf_georef (str)</code> <p>Path to folder containing georeferenced ToA reflectance files.</p> Source code in <code>ocm2/ocm2.py</code> <pre><code>def run_ocm2(path, hdf_file):\n\n\"\"\"\n    This is the main function of the script. It calls all the other functions. \n\n    Parameters:\n        path (str): Path to the folder containing the HDF files.\n        hdf_file (str): Name of the HDF file.\n\n    Returns:\n        opf_georef (str): Path to folder containing georeferenced ToA reflectance files.\n\n    \"\"\"\n\n    meta = metaInfo(path, hdf_file)\n    opf_tif = ExportSubdatasets(path, hdf_file)\n    print('Done: Layers converted to GeoTIFF. Wait.')\n\n    opf_ref = os.path.join(path, 'Reflectance')\n    if os.path.exists(opf_ref):\n        shutil.rmtree(opf_ref)\n    os.makedirs(opf_ref)\n\n    opf_georef = os.path.join(path, 'Georeferenced')\n    if os.path.exists(opf_georef):\n        shutil.rmtree(opf_georef)\n    os.makedirs(opf_georef)\n\n    do_ref(opf_tif, meta, opf_ref)\n    print('Done: Reflectance conversion. Wait.')\n\n    do_cldmsk(opf_ref)\n    print('Done: Cloudmasking. Wait.')\n\n    opf_georef = do_georef(opf_ref, meta, opf_georef)\n    print('Done: Georeferncing')\n\n    if os.path.exists(opf_tif):\n        shutil.rmtree(opf_tif)\n\n    if os.path.exists(opf_ref):\n        shutil.rmtree(opf_ref)\n\n    return opf_georef\n</code></pre>"},{"location":"ocm2/#ocm2.ocm2.sum_toa","title":"<code>sum_toa(filelist)</code>","text":"<p>This function sums the top of atmosphere reflectance values.</p> <p>Parameters:</p> Name Type Description Default <code>filelist</code> <code>list</code> <p>List containing the GeoTiff files.</p> required <p>Returns:</p> Type Description <code>arr (numpy array)</code> <p>Array containing the sum of the top of atmosphere reflectance values.</p> Source code in <code>ocm2/ocm2.py</code> <pre><code>def sum_toa(filelist):\n\n\"\"\"\n    This function sums the top of atmosphere reflectance values.\n\n    Parameters:\n        filelist (list): List containing the GeoTiff files.\n\n    Returns:\n        arr (numpy array): Array containing the sum of the top of atmosphere reflectance values.\n\n    \"\"\"\n\n    with rasterio.open(filelist[0]) as r:\n        arr = r.read()\n        profile = r.profile\n\n    for f in filelist[1:]:\n        with rasterio.open(f) as r:\n            assert profile == r.profile, 'stopping, file {} and  {} do not have matching profiles'.format(filelist[0], f)\n            arr = arr + r.read()\n\n    return (arr)\n</code></pre>"},{"location":"ocm2/#ocm2.ocm2.toa_convert","title":"<code>toa_convert(inpf, inp_name, opf, sun_elev)</code>","text":"<p>This function converts the radiance values to top of atmosphere reflectance values.</p> <p>Parameters:</p> Name Type Description Default <code>inpf</code> <code>str</code> <p>Path to the folder containing the GeoTiff files.</p> required <code>inp_name</code> <code>str</code> <p>Name of the GeoTiff file.</p> required <code>opf</code> <code>str</code> <p>Path to the folder containing the output GeoTiff files.</p> required <code>sun_elev</code> <code>float</code> <p>Sun elevation angle.</p> required <p>Returns:</p> Type Description <code>opf (str)</code> <p>Path to the folder containing the output GeoTiff files.</p> Source code in <code>ocm2/ocm2.py</code> <pre><code>def toa_convert(inpf, inp_name, opf, sun_elev):\n\n\"\"\"\n    This function converts the radiance values to top of atmosphere reflectance values.\n\n    Parameters:\n        inpf (str): Path to the folder containing the GeoTiff files.\n        inp_name (str): Name of the GeoTiff file.\n        opf (str): Path to the folder containing the output GeoTiff files.\n        sun_elev (float): Sun elevation angle.\n\n    Returns:\n        opf (str): Path to the folder containing the output GeoTiff files.\n\n    \"\"\"\n\n    band_no = int(''.join(list(filter(str.isdigit, inp_name.split('.')[0].split('_')[0]))))\n    with rasterio.open(os.path.join(inpf, inp_name)) as (r):\n        rad = r.read(1).astype('float32')\n        profile = r.profile\n\n    toa = calc_toa(rad, sun_elev, band_no)\n    toa[toa &lt; 0] = 0.0\n    toa[toa &gt; 2] = 0.0   \n    op_name = os.path.basename(inp_name).split('.')[0] + '.TIF'\n    with (rasterio.open)((os.path.join(opf, op_name)), 'w', **profile) as (dataset):\n        dataset.write(toa, 1)\n    dataset.close()\n\n    return opf\n</code></pre>"},{"location":"ocm2/#ocm2.ocm2.toa_other","title":"<code>toa_other(filelist)</code>","text":"<p>This function calculates the difference and ratio of the top of atmosphere reflectance values.</p> <p>Parameters:</p> Name Type Description Default <code>filelist</code> <code>list</code> <p>List containing the GeoTiff files.</p> required <p>Returns:</p> Type Description <code>toa_diff (numpy array)</code> <p>Array containing the difference of the top of atmosphere reflectance values. toa_ratio (numpy array): Array containing the ratio of the top of atmosphere reflectance values. shape (tuple): Tuple containing the shape of the GeoTiff file. profile (dict): Dictionary containing the profile of the GeoTiff file.</p> Source code in <code>ocm2/ocm2.py</code> <pre><code>def toa_other(filelist):\n\n\"\"\"\n    This function calculates the difference and ratio of the top of atmosphere reflectance values.\n\n    Parameters:\n        filelist (list): List containing the GeoTiff files.\n\n    Returns:\n        toa_diff (numpy array): Array containing the difference of the top of atmosphere reflectance values.\n        toa_ratio (numpy array): Array containing the ratio of the top of atmosphere reflectance values.\n        shape (tuple): Tuple containing the shape of the GeoTiff file.\n        profile (dict): Dictionary containing the profile of the GeoTiff file.\n\n    \"\"\"\n\n    one, two, seven = [filelist[check] for check in [0,1,6]]\n\n    with rasterio.open(one) as r:\n        band1 = r.read()\n        profile = r.profile\n    shape = band1.shape\n    with rasterio.open(two) as r:\n        band2 = r.read()\n    with rasterio.open(seven) as r:\n        band7 = r.read()\n\n\n    band2[band2 == 0.0] = np.nan\n    band7[band7 == 0.0] = np.nan\n\n    toa_diff = band2 - band1\n    toa_ratio = band2/band7 \n\n    return (toa_diff, toa_ratio, shape, profile)\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>To use ocm2 in a project:</p> <pre><code>import ocm2\n</code></pre>"}]}